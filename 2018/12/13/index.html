<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Guava Retrying - Hello World</title><meta name=author content="Shell Ming"><meta name=description content="A blog about everything."><meta name=generator content="Hugo 0.52"><link rel=stylesheet href=/assets/css/external.min.css media=screen><link rel=stylesheet href=/assets/css/styles.css media=screen><link href="//fonts.googleapis.com/css?family=Roboto:400" rel=stylesheet><link rel=apple-touch-icon-precomposed sizes=144x144 href=/assets/img/apple-touch-icon.png><link rel="shortcut icon" href=/assets/img/favicon.ico><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Hello World"><link href=/posts/index.xml rel=feed type=application/rss+xml title="Hello World"><meta property=og:title content="Guava Retrying"><meta property=og:description content="简介 Guava Retrying 是一个灵活的 Java 重试工具，该工具基于Guava 的 predicate 机制， 提供了处理各种停止、重试、异常处理的能力。相较于 Spring Retry 只能根据抛出的异常决定是否重试，Guava Retrying 可以根据返回结果来决定是否重试，功能更加强大。项目 Github 地址
基本使用 官网的基本用例
Callable&lt;Boolean&gt; callable = new Callable&lt;Boolean&gt;() { public Boolean call() throws Exception { return true; // do something useful here } }; Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder() .retryIfResult(Predicates.&lt;Boolean&gt;isNull()) .retryIfExceptionOfType(IOException.class) .retryIfRuntimeException() .withStopStrategy(StopStrategies.stopAfterAttempt(3)) .build(); try { retryer.call(callable); } catch (RetryException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }  重试条件：结果返回 null 或者抛出 IOException 或者抛出 RuntimeException 停止条件：尝试三次，失败后停止 RetryException：尝试失败后抛出，包含了失败信息 ExecutionException：执行过程中抛出了预料之外的异常，终止了执行  Fibonacci Backoff 一直重试，永不停止，每次重试失败后的间隔时间为一个斐波那契数列，最大间隔时间为2分钟"><meta property=og:type content=article><meta property=og:url content=https://shellming.github.io/2018/12/13/><meta property=article:published_time content=2018-12-13T00:00:00&#43;00:00><meta property=article:modified_time content=2018-12-13T00:00:00&#43;00:00><meta itemprop=name content="Guava Retrying"><meta itemprop=description content="简介 Guava Retrying 是一个灵活的 Java 重试工具，该工具基于Guava 的 predicate 机制， 提供了处理各种停止、重试、异常处理的能力。相较于 Spring Retry 只能根据抛出的异常决定是否重试，Guava Retrying 可以根据返回结果来决定是否重试，功能更加强大。项目 Github 地址
基本使用 官网的基本用例
Callable&lt;Boolean&gt; callable = new Callable&lt;Boolean&gt;() { public Boolean call() throws Exception { return true; // do something useful here } }; Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder() .retryIfResult(Predicates.&lt;Boolean&gt;isNull()) .retryIfExceptionOfType(IOException.class) .retryIfRuntimeException() .withStopStrategy(StopStrategies.stopAfterAttempt(3)) .build(); try { retryer.call(callable); } catch (RetryException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }  重试条件：结果返回 null 或者抛出 IOException 或者抛出 RuntimeException 停止条件：尝试三次，失败后停止 RetryException：尝试失败后抛出，包含了失败信息 ExecutionException：执行过程中抛出了预料之外的异常，终止了执行  Fibonacci Backoff 一直重试，永不停止，每次重试失败后的间隔时间为一个斐波那契数列，最大间隔时间为2分钟"><meta itemprop=datePublished content=2018-12-13T00:00:00&#43;00:00><meta itemprop=dateModified content=2018-12-13T00:00:00&#43;00:00><meta itemprop=wordCount content=130><meta itemprop=keywords content=java,retry,重试,><meta name=twitter:card content=summary><meta name=twitter:title content="Guava Retrying"><meta name=twitter:description content="简介 Guava Retrying 是一个灵活的 Java 重试工具，该工具基于Guava 的 predicate 机制， 提供了处理各种停止、重试、异常处理的能力。相较于 Spring Retry 只能根据抛出的异常决定是否重试，Guava Retrying 可以根据返回结果来决定是否重试，功能更加强大。项目 Github 地址
基本使用 官网的基本用例
Callable&lt;Boolean&gt; callable = new Callable&lt;Boolean&gt;() { public Boolean call() throws Exception { return true; // do something useful here } }; Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder() .retryIfResult(Predicates.&lt;Boolean&gt;isNull()) .retryIfExceptionOfType(IOException.class) .retryIfRuntimeException() .withStopStrategy(StopStrategies.stopAfterAttempt(3)) .build(); try { retryer.call(callable); } catch (RetryException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }  重试条件：结果返回 null 或者抛出 IOException 或者抛出 RuntimeException 停止条件：尝试三次，失败后停止 RetryException：尝试失败后抛出，包含了失败信息 ExecutionException：执行过程中抛出了预料之外的异常，终止了执行  Fibonacci Backoff 一直重试，永不停止，每次重试失败后的间隔时间为一个斐波那契数列，最大间隔时间为2分钟"></head><body><nav><a href=/>Shell Ming</a></nav><main class=container><article><header><small><time datetime="2018-12-13 12:00">2018-12-13</time>
&bull;
<a href=/categories/development>DEVELOPMENT</a></small><h1>Guava Retrying</h1></header><section><h4 id=简介>简介</h4><p>Guava Retrying 是一个灵活的 Java 重试工具，该工具基于Guava 的 predicate 机制， 提供了处理各种停止、重试、异常处理的能力。相较于 Spring Retry 只能根据抛出的异常决定是否重试，Guava Retrying 可以根据返回结果来决定是否重试，功能更加强大。<a href=https://github.com/rholder/guava-retrying>项目 Github 地址</a></p><h4 id=基本使用>基本使用</h4><p>官网的基本用例</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Callable</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>callable</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Callable</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;()</span> <span class=o>{</span>

<span class=kd>public</span> <span class=n>Boolean</span> <span class=nf>call</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
<span class=k>return</span> <span class=kc>true</span><span class=o>;</span> <span class=c1>// do something useful here
</span><span class=c1></span><span class=o>}</span>
<span class=o>};</span>

<span class=n>Retryer</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>retryer</span> <span class=o>=</span> <span class=n>RetryerBuilder</span><span class=o>.&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=n>newBuilder</span><span class=o>()</span>
<span class=o>.</span><span class=na>retryIfResult</span><span class=o>(</span><span class=n>Predicates</span><span class=o>.&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=n>isNull</span><span class=o>())</span>
<span class=o>.</span><span class=na>retryIfExceptionOfType</span><span class=o>(</span><span class=n>IOException</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=o>.</span><span class=na>retryIfRuntimeException</span><span class=o>()</span>
<span class=o>.</span><span class=na>withStopStrategy</span><span class=o>(</span><span class=n>StopStrategies</span><span class=o>.</span><span class=na>stopAfterAttempt</span><span class=o>(</span><span class=n>3</span><span class=o>))</span>
<span class=o>.</span><span class=na>build</span><span class=o>();</span>
<span class=k>try</span> <span class=o>{</span>
<span class=n>retryer</span><span class=o>.</span><span class=na>call</span><span class=o>(</span><span class=n>callable</span><span class=o>);</span>
<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>RetryException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
<span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>ExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
<span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
<span class=o>}</span></code></pre></div><ul><li>重试条件：结果返回 null 或者抛出 <code>IOException</code> 或者抛出 <code>RuntimeException</code></li><li>停止条件：尝试三次，失败后停止</li><li><code>RetryException</code>：尝试失败后抛出，包含了失败信息</li><li><code>ExecutionException</code>：执行过程中抛出了预料之外的异常，终止了执行</li></ul><h4 id=fibonacci-backoff>Fibonacci Backoff</h4><p>一直重试，永不停止，每次重试失败后的间隔时间为一个斐波那契数列，最大间隔时间为2分钟</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Retryer</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>retryer</span> <span class=o>=</span> <span class=n>RetryerBuilder</span><span class=o>.&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=n>newBuilder</span><span class=o>()</span>
        <span class=o>.</span><span class=na>retryIfExceptionOfType</span><span class=o>(</span><span class=n>IOException</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
        <span class=o>.</span><span class=na>retryIfRuntimeException</span><span class=o>()</span>
        <span class=o>.</span><span class=na>withWaitStrategy</span><span class=o>(</span><span class=n>WaitStrategies</span><span class=o>.</span><span class=na>fibonacciWait</span><span class=o>(</span><span class=n>100</span><span class=o>,</span> <span class=n>2</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MINUTES</span><span class=o>))</span>
        <span class=o>.</span><span class=na>withStopStrategy</span><span class=o>(</span><span class=n>StopStrategies</span><span class=o>.</span><span class=na>neverStop</span><span class=o>())</span>
        <span class=o>.</span><span class=na>build</span><span class=o>();</span></code></pre></div><h4 id=遇到的问题>遇到的问题</h4><p>如果最终尝试失败，如何获取最后一次返回的结果，或者最后一次抛出的异常</p><h4 id=解决方案>解决方案</h4><p>翻一下 <code>RetryException</code> 的源码，最近一次重试尝试由 <code>Attempt&lt;?&gt; lastFailedAttempt</code> 这个字段保存， <code>Attempt</code> 有两个实现， <code>ExceptionAttempt</code> 和 <code>ResultAttempt</code>，调用 <code>Attempt.get()</code>，前者抛出 <code>ExecutionException</code> 异常，后者返回结果，<code>ExecutionException</code> 包装了我们真正的异常，所以最终代码如下：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=n>Object</span> <span class=nf>getLastResult</span><span class=o>(</span><span class=n>RetryException</span> <span class=n>exception</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span>
<span class=n>Attempt</span> <span class=n>attempt</span> <span class=o>=</span> <span class=n>exception</span><span class=o>.</span><span class=na>getLastFailedAttempt</span><span class=o>();</span>
<span class=k>try</span> <span class=o>{</span>
<span class=k>return</span> <span class=n>attempt</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>ExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
<span class=k>throw</span> <span class=n>e</span><span class=o>.</span><span class=na>getCause</span><span class=o>();</span>
<span class=o>}</span>
<span class=o>}</span></code></pre></div></section><footer><hr><div class=meta><p class=tags><a href=/tags/java><span>#</span>java</a>
<a href=/tags/retry><span>#</span>retry</a>
<a href=/tags/%E9%87%8D%E8%AF%95><span>#</span>重试</a></p></div><hr><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"test"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></main><footer><p>&copy; 2018 Shell Ming. <a href=http://creativecommons.org/licenses/by-sa/4.0/>Some Rights Reserved</a>.</p><p>Powered by <a href=https://gohugo.io title="A Fast and Flexible Website Generator">Hugo</a> &amp; <a href=https://github.com/eshlox/simplicity title="Hugo theme">Simplicity</a>.</p></footer><script src=/assets/js/scripts.min.js></script></body></html>